= Gateway pattern

Although it is probably pretty clear that an (API) Gateway is meant to be between the caller of services (resource servers) and a client, there are still many subtle different deployment scenarios. The most noticeable differences being mostly related to whether or not the client is a browser-based app and if-so whether or not the app, gateway and/or identify provider (IdP) share the same domain.

Additional reverse-proxy scenario's aside, this basically means if the app itself as well the IdP are served through the gateway or not.

The main focus of this exploration of a Gateway is for a browser-based as client, but its mostly applicable to native apps as well.

https://tools.ietf.org/html/draft-ietf-oauth-browser-based-apps-03[This new draft] states
[quote, oauth-browser-based-apps]
_____
the current best practice for browser-based applications is to use the OAuth 2.0 authorization code flow with PKCE.
_____

The same spec also makes a few other interesting statements:

[quote, oauth-browser-based-apps]
____
. it is best to avoid letting the JavaScript code ever see the access token ... to keep access tokens out of the browser.
. If your JavaScript application has no backend, but still shares a domain with the resource server, then it may be best to avoid using OAuth entirely.
____

Basically summing up to preferring good old session cookie-based AuthN to your browser app if you can, or using the absolute safest OAuth 2.0 flow fully client-side if you must.

With that in mind, lets see what this actually means when introducing a Gateway and the desire to off-load AuthN/AuthZ as much as possible to an external product such as Keycloak.

== Stateful

Just like the most standard scenario for the OAuth authorization code flow, we could have the gateway serve as typical backend. Taking care of exchanging any authorization code received after login for the actual access and refresh tokens server-side and storing them in a session.

Effectively playing backend for any JavaScript app that it serves. Personally I consider this the best and safest option for browser-based apps. Mainly due to simplicity this provides to you client apps. However cookies are not really suited for native-apps and this does require building your own stateful session management in your Gateway.

A solution following this architecture using the latest and greatest reactive goodness of Spring Boot, Security, Session and Cloud Gateway can be found at *stateful-oauth-gateway*.

== Stateless

Another option would be to embrace full OAuth on the client-side and have your IdP and app conform to the requirements as stated the https://tools.ietf.org/html/draft-ietf-oauth-browser-based-apps-03[spec] above.
Basically providing an browser app with the _access_token_ (stored inside the _sessionStore_) and calling the Gateway with

	Authorization: Bearer <access_token>

This way almost anything can serve as the Gateway and transparently proxy the request to the proper service. The major drawback being that the access token usable throughout your service landscape is directly exposed to the client, likely leaving your internal network. While this is technically feasible it would do a pretty poor job playing Gateway.

Enter https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-19[token-exchange]. Leveraging Keycloak's https://www.keycloak.org/docs/latest/securing_apps/index.html#\_token-exchange[Tech Preview] support for __token exchange__ it should be possible to create a Gateway that dynamically exchanges incoming access tokens representing the user, for an access token intended for internal use, when proxying API calls. The gotcha being that only the Gateway should be allowed to do this, using the same `token` endpoint as used by the client app itself.

A reactive solution following this architecture using the latest and greatest goodness of Spring Boot, Security and Cloud Gateway 2 can be found at *stateless-oauth-gateway*

=== Stateless code exchange

If prefer to stick with automatic cookie-based _AuthN_ without JavaScript being able to touch any of the tokens you could also have the Gateway do the code exchange and deliver the tokens as http-only cookies.