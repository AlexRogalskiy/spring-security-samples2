= Adding Spring Security

Adding Spring Security to an existing application can be quite a daunting prospect.
Merely adding the required dependencies to your project sets off a chain of events which can break your application and tests.

Maybe you're suddenly shown a login prompt which expects a generated password logged on startup. +
Maybe your tests now get the dreaded `401 Unauthorized`, or a subsequently a `403 Forbidden`. +
Maybe you get a `ClassCastException` when trying to use your `Authentication#getPrincipal()`. +
Either way, this post is here to help!

We will walk you through adding Spring Security to an existing application,
by explaining what happens when you first add the dependencies, what to do next, and how to fix your tests.

== Our initial application
To showcase adding Spring Security we've developed a small application, along with some tests of it's functionality.
Imagine a Human Resources department that has a small application to track and approve/deny leave requests.
Initially this application was only used from within the HR department, who received requests via phone or email.

Now we want to open up this application to all employees, so they can file their leave requests themselves.
Anyone from the HR department can then either approve or deny a leave request.
Simple enough! For a version of our application without any security in place have a look at https://github.com/timtebeek/spring-security-samples/tree/master/adding-spring-security/leaveapp-initial[leaveapp-initial].

== Which dependency to add?
The first step in adding security to our application is picking the right dependency to add to our project.
However, even figuring out which dependency to add can be difficult these days!
Looking at https://start.spring.io/#!type=maven-project&&jvmVersion=11&dependencies=security,oauth2-client,cloud-security,cloud-oauth2,oauth2-resource-server[start.spring.io]
we can see there are already 5 different dependencies related to Spring Security and/or OAuth2.
In part this is down to a https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security[restructuring of OAuth2 support],
with OAuth2 resource server and client support now https://github.com/spring-projects/spring-security/wiki/OAuth-2.0-Features-Matrix[moved into Spring Security 5.2+].

In short we now advise against using the Spring Cloud Starter dependencies, and push towards using Spring Security support for OAuth2.

If your service will act as an OAuth2 resource server, by accepting JSON Web Tokens passed in from a gateway, you can use `spring-boot-starter-oauth2-resource-server`.
We expect this to be the most common form within a micro-services landscape, where a central gateway assumes the OAuth2 client role.
It is also what we will use throughout this blog post, although much of the lessons learned apply to other forms as well.

If your service will act as an OAuth2 client to acquire JSON Web Tokens, you'll most likely want to use `spring-boot-starter-oauth2-client`.

Both starters will provide you with any transitive dependencies you might need for the most common security aspects.

== What happens when you add the dependency?
We add a dependency on `spring-boot-starter-oauth2-resource-server` to our initial application.
Then we start our application by running `LeaveRequestApplication`, and point our browser towards `http://localhost:8080/view/all`.
Now before adding the dependency this endpoint would show all the leave requests for all employees.
After adding the dependency, this endpoint now throws up a sign in dialog, which we certainly never configured!

image:docs/signin.png[alt='Please sign in']

If we try to open the same endpoint from the commandline we immediately get a `HTTP/1.1 401` response.

We turn to the application logs to find out what happened in our application.
As it turns out, there's a curious new logline from https://github.com/spring-projects/spring-boot/blob/2.2.x/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/servlet/UserDetailsServiceAutoConfiguration.java[`UserDetailsServiceAutoConfiguration`]:
----
2019-11-09 17:00:46.665  INFO 709 --- [           main] .s.s.UserDetailsServiceAutoConfiguration : 

Using generated security password: fcf786f4-797b-499b-9abc-2cee4037edb3
----
This auto configration triggers when no other security configuration has been provided.
It sets up our application with a default user and generated password, as a fallback of sorts.
After all, if you're adding Spring Security to your classpath you will want some form of security.
At the very least it serves as a trigger to configure exactly what you want in your application.

=== OAuth2 Resource server configuration
Since we wish to configure our application to function as an OAuth2 resource server, we can provide the required configuration to make the generated security password go away.
https://docs.spring.io/spring-security/site/docs/5.2.x/reference/htmlsingle/#oauth2resourceserver[As indicated in the documentation], configuration takes the form of:
[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:8090/auth/realms/spring-cloud-gateway-realm
----
Our application will now call out to the configured `issuer-uri` during startup, to configure the `JwtDecoder`.
During development we will use either Keycloak or WireMock to serve the configured `issuer-uri` endpoint.

Once this configuration is in place we can restart our application.
Looking at the logs we no longer see the generated password; Great!
The `UserDetailsServiceAutoConfiguration` from before has instead been replaced by https://github.com/spring-projects/spring-boot/blob/2.2.x/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/security/oauth2/resource/servlet/OAuth2ResourceServerJwtConfiguration.java[`OAuth2ResourceServerJwtConfiguration`], which has provided us with a `JwtDecoder` to handle incoming tokens.
Unless you provide your own `WebSecurityConfigurerAdapter`, this sets up your application to required a JSON Web Token for each request.

When we now call any application endpoint we consistently get a `401 Unauthorized` response, since our requests lack a `Authorization` header with  `Bearer` JSON Web Token.
To solve this, we have to actually pass a Bearer token along with our requests.
Here's a token and command to get your request through with a `HTTP/1.1 200`:

.Click to show full JSON Web Token
[%collapsible]
====
eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJRSS1mdW1sLTRyTnBrdVZxWVg0elpuZlRUZW1hSkxoZ183Z0dULTZiSFlVIn0.eyJqdGkiOiI4MTAzNTI4MC04YTdjLTRjOTktYWMzMi05MDJkMTY0YWVjZWEiLCJleHAiOjE2NTk3MjcxMzgsIm5iZiI6MCwiaWF0IjoxNTczMzI3MTM4LCJpc3MiOiJodHRwOi8vbG9jYWxob3N0OjgwOTAvYXV0aC9yZWFsbXMvc3ByaW5nLWNsb3VkLWdhdGV3YXktcmVhbG0iLCJhdWQiOiJhY2NvdW50Iiwic3ViIjoiOWJhNDA5YmYtM2ZhOC00MjdjLWI4YmMtOGFlNjYwNmUyOTAyIiwidHlwIjoiQmVhcmVyIiwiYXpwIjoic3ByaW5nLWNsb3VkLWdhdGV3YXktY2xpZW50Iiwibm9uY2UiOiJnTVdjMTR1WHZMQk9QVlNTRG96NWFUMWNQSUNoVmZzMXFNVHhSWGJPWDBJIiwiYXV0aF90aW1lIjoxNTczMzI3MTM4LCJzZXNzaW9uX3N0YXRlIjoiYWExMmJlZDgtYTlkNC00YTBlLTgyYjAtNTIxMDUwZTAwODA1IiwiYWNyIjoiMSIsInJlYWxtX2FjY2VzcyI6eyJyb2xlcyI6WyJvZmZsaW5lX2FjY2VzcyIsInVtYV9hdXRob3JpemF0aW9uIl19LCJyZXNvdXJjZV9hY2Nlc3MiOnsiYWNjb3VudCI6eyJyb2xlcyI6WyJtYW5hZ2UtYWNjb3VudCIsIm1hbmFnZS1hY2NvdW50LWxpbmtzIiwidmlldy1wcm9maWxlIl19fSwic2NvcGUiOiJvcGVuaWQgcGhvbmUgbWljcm9wcm9maWxlLWp3dCBvZmZsaW5lX2FjY2VzcyBwcm9maWxlIGVtYWlsIGFkZHJlc3MiLCJ1cG4iOiJzcHJpbmctY2xvdWQtZ2F0ZXdheS11c2VyIiwiZW1haWxfdmVyaWZpZWQiOmZhbHNlLCJhZGRyZXNzIjp7fSwiZ3JvdXBzIjpbIm9mZmxpbmVfYWNjZXNzIiwidW1hX2F1dGhvcml6YXRpb24iXSwicHJlZmVycmVkX3VzZXJuYW1lIjoic3ByaW5nLWNsb3VkLWdhdGV3YXktdXNlciJ9.HoQ86lJhILWhvZUfefJdxHdTqb4jZFkdWTKHzOAxhNApc9YIgv1zLLlMAXFJHgL1ITY9R1Ke2-SUqMG8d1djPA6D6YRJn4MpWyiS66qpBuRNHg47c9dc-cBLUkXLy9nBZFget87_ZHNhXG_v3MILhH0VbKIWafOTdoJLhJOSy6aQ44iAMjCKXZgMv7EcfvXmwAquaJGGB_fgUa2FXztnt_Fwq4nLgbkU-UYXIqycJVb1gaBbfHmbPpq4pZrkc2Q_9d5FSLGeHIkGmeq17kJLKDzXmvDFu3J5X43nSIaH_WhqSeKkeYAb5HK_xXJnQhRSzku9kYm3dd7z9GBJuSMpRQ
====
[source,bash]
----
$ export token=eyJhbGc...
$ http :8080/view/all "Authorization: Bearer ${token}" 
----
Perfect! Now we have the basics in place to pass our authentication to our application.

=== Fixing our tests; part 1
Now we have an application that requires an OpenID Connect provider on startup, and a valid JWT for any request.
Neither plays well with the tests we have, so we're going to have to fix each of the four different test flavors we have.

==== WebMvcTests
First up we wish to make `LeaveRequestControllerWebMvcTest` pass again; We're testing the controller in isolation here, using `@WebMvc` together with `MockMvc`.
Running the tests we see `GET` requests now get a `401 Unauthorized` response, while `POST` requests get a `403 Forbidden` response.
We want to authenticate for these web requests, which we can achieve by adding the https://docs.spring.io/spring-security/site/docs/5.2.x/reference/html/test.html[`spring-security-test`] library to our test class path.
This library provides us with the `@WithMockUser` annotation, among others, which we add to our test class or any of it's methods.
If you rerun the tests, you'll find the `GET` requests now pass.
However, the `POST` requests keep failing with a `403` response.
As it turns out, debug logging points us in the right direction:
----
2019-11-10 14:44:44.460 DEBUG 23815 --- [           main] o.s.security.web.csrf.CsrfFilter         : Invalid CSRF token found for http://localhost/approve/4570ec01-9640-4873-a75b-59a8b4983d9e
----
By default Spring Security adds https://docs.spring.io/spring-security/site/docs/5.2.x/reference/htmlsingle/#servlet-csrf[Cross Site Request Forgery] protection for `POST` requests.
This protects our resource server from malicious requests; and we choose not the disable this just yet.
Because of this, we do have to add `csrf` tokens to our POST requests, which is again provided through `spring-security-test`.
With both `@WithMockUser` and `post("...").with(csrf())` in place, now all tests within `LeaveRequestControllerWebMvcTest` pass again!

==== SpringBootTest with WebEnvironment.MOCK
Next up is our `LeaveRequestControllerSpringBootWebEnvMockTest`, which now requires Keycloak to start.
While locally this might be manageable, for CI/CD environments and general test stability it's far from ideal.
Therefore we would like to make this test pass without the need for the configured `issuer-uri` to be available.
We can achieve this fairly easily by providing a `@MockBean JwtDecoder`, which bypasses the call to our `issuer-uri`, https://docs.spring.io/spring-security/site/docs/5.2.x/reference/htmlsingle/#literal-authentication-literal-literal-requestpostprocessor-literal[as alluded to in the documentation].
With the MockBean in place we can see the test application context now starts up again, even when the OpenID Connect provider is unavailable.
At this point we see the same failure modes as we saw previously: `GET` requests get a `401` response, wehereas `POST` requests get a `403` response.
We add the same fixes as previously applied to `LeaveRequestControllerWebMvcTest` to make all tests pass again.

==== SpringBootTest with WebEnvironment.RANDOM_PORT


== Configuring web security
Next up: configuring our application security such that we can restrict access properly.


== Configuring method security

=== Service tests


== Fixing our tests

=== `@WebMvcTest()`

=== `@SpringBootTest()`

=== Integration tests

=== Non-web tests



== Conclusion


== References
https://docs.spring.io/spring-security/site/docs/5.2.x/reference/htmlsingle/#oauth2resourceserver[OAuth 2.0 Resource Server] +
